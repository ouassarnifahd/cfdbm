#include "common.h"
#include "dft.h"

// fcomplex_t fft_R = {
//     fft_re_R,
//     fft_im_R,
// };
//
// fcomplex_t fft_L = {
//     fft_re_L,
//     fft_im_L,
// };

// Twiddle factors (512 roots of unity)
const float W[] = {
    1.00000, 0.99992, 0.99970, 0.99932, 0.99880, 0.99812, 0.99729, 0.99631,
    0.99518, 0.99391, 0.99248, 0.99090, 0.98918, 0.98730, 0.98528, 0.98311,
    0.98079, 0.97832, 0.97570, 0.97294, 0.97003, 0.96698, 0.96378, 0.96043,
    0.95694, 0.95331, 0.94953, 0.94561, 0.94154, 0.93734, 0.93299, 0.92851,
    0.92388, 0.91911, 0.91421, 0.90917, 0.90399, 0.89867, 0.89322, 0.88764,
    0.88192, 0.87607, 0.87009, 0.86397, 0.85773, 0.85135, 0.84485, 0.83822,
    0.83147, 0.82459, 0.81758, 0.81046, 0.80321, 0.79584, 0.78835, 0.78074,
    0.77301, 0.76517, 0.75721, 0.74914, 0.74095, 0.73265, 0.72425, 0.71573,
    0.70711, 0.69837, 0.68954, 0.68060, 0.67156, 0.66241, 0.65317, 0.64383,
    0.63439, 0.62486, 0.61523, 0.60551, 0.59570, 0.58580, 0.57581, 0.56573,
    0.55557, 0.54532, 0.53500, 0.52459, 0.51410, 0.50354, 0.49290, 0.48218,
    0.47139, 0.46054, 0.44961, 0.43861, 0.42755, 0.41643, 0.40524, 0.39399,
    0.38268, 0.37131, 0.35989, 0.34842, 0.33689, 0.32531, 0.31368, 0.30200,
    0.29028, 0.27852, 0.26671, 0.25486, 0.24298, 0.23106, 0.21910, 0.20711,
    0.19509, 0.18304, 0.17096, 0.15885, 0.14673, 0.13458, 0.12241, 0.11022,
    0.09801, 0.08579, 0.07356, 0.06132, 0.04906, 0.03680, 0.02454, 0.01227,
   -0.00000,-0.01228,-0.02454,-0.03681,-0.04907,-0.06132,-0.07357,-0.08580,
   -0.09802,-0.11023,-0.12241,-0.13458,-0.14673,-0.15886,-0.17097,-0.18304,
   -0.19509,-0.20712,-0.21911,-0.23106,-0.24298,-0.25487,-0.26672,-0.27852,
   -0.29029,-0.30201,-0.31369,-0.32531,-0.33689,-0.34842,-0.35990,-0.37132,
   -0.38269,-0.39400,-0.40525,-0.41643,-0.42756,-0.43862,-0.44962,-0.46054,
   -0.47140,-0.48219,-0.49290,-0.50354,-0.51411,-0.52459,-0.53500,-0.54533,
   -0.55557,-0.56574,-0.57581,-0.58580,-0.59570,-0.60552,-0.61524,-0.62486,
   -0.63440,-0.64384,-0.65318,-0.66242,-0.67156,-0.68060,-0.68954,-0.69838,
   -0.70711,-0.71573,-0.72425,-0.73266,-0.74095,-0.74914,-0.75721,-0.76517,
   -0.77301,-0.78074,-0.78835,-0.79584,-0.80321,-0.81046,-0.81759,-0.82459,
   -0.83147,-0.83823,-0.84486,-0.85136,-0.85773,-0.86398,-0.87009,-0.87607,
   -0.88192,-0.88764,-0.89323,-0.89868,-0.90399,-0.90917,-0.91421,-0.91912,
   -0.92388,-0.92851,-0.93300,-0.93734,-0.94155,-0.94561,-0.94953,-0.95331,
   -0.95694,-0.96043,-0.96378,-0.96698,-0.97003,-0.97294,-0.97570,-0.97832,
   -0.98079,-0.98311,-0.98528,-0.98730,-0.98918,-0.99090,-0.99248,-0.99391,
   -0.99519,-0.99631,-0.99729,-0.99812,-0.99880,-0.99932,-0.99970,-0.99992,
   -1.00000,-0.99992,-0.99970,-0.99932,-0.99880,-0.99812,-0.99729,-0.99631,
   -0.99518,-0.99391,-0.99248,-0.99090,-0.98918,-0.98730,-0.98528,-0.98310,
   -0.98078,-0.97832,-0.97570,-0.97294,-0.97003,-0.96697,-0.96377,-0.96043,
   -0.95694,-0.95330,-0.94953,-0.94560,-0.94154,-0.93734,-0.93299,-0.92850,
   -0.92388,-0.91911,-0.91421,-0.90916,-0.90399,-0.89867,-0.89322,-0.88764,
   -0.88192,-0.87607,-0.87008,-0.86397,-0.85772,-0.85135,-0.84485,-0.83822,
   -0.83146,-0.82458,-0.81758,-0.81045,-0.80320,-0.79583,-0.78834,-0.78073,
   -0.77300,-0.76516,-0.75720,-0.74913,-0.74095,-0.73265,-0.72424,-0.71572,
   -0.70710,-0.69837,-0.68953,-0.68059,-0.67155,-0.66241,-0.65317,-0.64382,
   -0.63439,-0.62485,-0.61522,-0.60550,-0.59569,-0.58579,-0.57580,-0.56572,
   -0.55556,-0.54532,-0.53499,-0.52458,-0.51409,-0.50353,-0.49289,-0.48218,
   -0.47139,-0.46053,-0.44960,-0.43861,-0.42755,-0.41642,-0.40523,-0.39398,
   -0.38267,-0.37131,-0.35989,-0.34841,-0.33688,-0.32530,-0.31367,-0.30200,
   -0.29027,-0.27851,-0.26670,-0.25486,-0.24297,-0.23105,-0.21909,-0.20710,
   -0.19508,-0.18303,-0.17095,-0.15885,-0.14672,-0.13457,-0.12240,-0.11021,
   -0.09801,-0.08579,-0.07355,-0.06131,-0.04906,-0.03680,-0.02453,-0.01226,
    0.00001, 0.01228, 0.02455, 0.03682, 0.04908, 0.06133, 0.07358, 0.08581,
    0.09803, 0.11023, 0.12242, 0.13459, 0.14674, 0.15887, 0.17097, 0.18305,
    0.19510, 0.20712, 0.21911, 0.23107, 0.24299, 0.25488, 0.26672, 0.27853,
    0.29030, 0.30202, 0.31369, 0.32532, 0.33690, 0.34843, 0.35991, 0.37133,
    0.38269, 0.39400, 0.40525, 0.41644, 0.42757, 0.43863, 0.44962, 0.46055,
    0.47141, 0.48219, 0.49291, 0.50355, 0.51411, 0.52460, 0.53501, 0.54534,
    0.55558, 0.56574, 0.57582, 0.58581, 0.59571, 0.60552, 0.61524, 0.62487,
    0.63440, 0.64384, 0.65318, 0.66243, 0.67157, 0.68061, 0.68955, 0.69839,
    0.70712, 0.71574, 0.72426, 0.73266, 0.74096, 0.74915, 0.75722, 0.76518,
    0.77302, 0.78075, 0.78835, 0.79584, 0.80322, 0.81046, 0.81759, 0.82460,
    0.83148, 0.83823, 0.84486, 0.85136, 0.85774, 0.86398, 0.87009, 0.87608,
    0.88193, 0.88765, 0.89323, 0.89868, 0.90400, 0.90917, 0.91422, 0.91912,
    0.92388, 0.92851, 0.93300, 0.93734, 0.94155, 0.94561, 0.94953, 0.95331,
    0.95694, 0.96043, 0.96378, 0.96698, 0.97003, 0.97294, 0.97571, 0.97832,
    0.98079, 0.98311, 0.98528, 0.98730, 0.98918, 0.99090, 0.99248, 0.99391,
    0.99519, 0.99631, 0.99729, 0.99812, 0.99880, 0.99932, 0.99970, 0.99992
};

float log2f_approx_coeff[4] = {1.23149591368684f, -4.11852516267426f, 6.02197014179219f, -3.13396450166353f};

INVISIBLE float FastArcTan(float x) {
    return 0.7853 * x - x * ((int)x - 1) * (0.2447 + 0.0663 * (int)x);
}

INVISIBLE float log2f_approx(float X) {
    float *C = &log2f_approx_coeff[0];
    float Y;
    float F;
    int E;

    // This is the approximation to log2()
    F = frexpf(fabsf(X), &E);

    //  Y = C[0]*F*F*F + C[1]*F*F + C[2]*F + C[3] + E;
    Y = *C++;
    Y *= F;
    Y += (*C++);
    Y *= F;
    Y += (*C++);
    Y *= F;
    Y += (*C++);
    Y += E;
    return(Y);
}

#define log10f_fast(x)  (log2f_approx(x)*0.3010299956639812f)

// TODO debug and check results

void dft_pow_ang(float* x, fcomplex_t* X, float* P, float* A, size_t len) {

    // time and frequency domain data arrays
    int n, k;      // time and frequency domain indices

    // Calculate DFT and power spectrum up to Nyquist frequency
    int to_sin = 3 * len / 4; // index offset for sin
    int a, b;
    for (k = 0; k <= len/2; ++k) {
        X->re[k] = 0; X->im[k] = 0;
        a = 0; b = to_sin;
        for (n = 0; n < len; ++n) {
            X->re[k] += x[n] * W[a % len];
            X->im[k] -= x[n] * W[b % len];
            a += k; b += k;
        }
        P[k] = X->re[k] * X->re[k] + X->im[k] * X->im[k];
        A[k] = FastArcTan(X->im[k] / X->re[k]);
    }
}

void dft2_IPD_ILD(float* xl, float* xr, fcomplex_t* Xl, fcomplex_t* Xr, float* ILD, float* IPD, size_t len) {

    // time and frequency domain data arrays
    int n, k;      // time and frequency domain indices
    float Xr_l_re, Xr_l_im, P;

    // Calculate DFT and power spectrum up to Nyquist frequency
    int to_sin = 3 * len / 4; // index offset for sin
    int a, b;
    for (k = 0; k <= len/2; ++k) {
        Xl->re[k] = 0; Xl->im[k] = 0;
        Xr->re[k] = 0; Xr->im[k] = 0;
        a = 0; b = to_sin;
        for (n = 0; n < len; ++n) {
            Xl->re[k] += xl[n] * W[a % len];
            Xl->im[k] -= xl[n] * W[b % len];
            Xr->re[k] += xr[n] * W[a % len];
            Xr->im[k] -= xr[n] * W[b % len];
            a += k; b += k;
        }

        P = Xl->re[k] * Xl->re[k] + Xl->im[k] * Xl->im[k];
        Xr_l_re  = Xr->re[k] * Xl->re[k];
        Xr_l_im  = Xr->re[k] * Xl->im[k];
        Xr_l_re -= Xr->im[k] * Xl->im[k];
        Xr_l_im += Xr->im[k] * Xl->re[k];
        Xr_l_re /= P;
        Xr_l_im /= P;
        IPD[k] = FastArcTan(Xr_l_im / Xr_l_re);
        ILD[k] = 20 * log10f_fast(Xr_l_re * Xr_l_re + Xr_l_im * Xr_l_im);
    }
}

void idft(fcomplex_t* X, float* x, size_t len) {

    // time and frequency domain data arrays
    int n, k;      // time and frequency domain indices

    // Calculate IDFT
    int to_sin = 3 * len / 4; // index offset for sin
    int a, b;
    for (n = 0; n < len; ++n) {
        x[n] = 0;
        a = 0; b = to_sin;
        for (k = 0; k < len; ++k) {
            if (k <= len/2) {
                x[n] += X->re[k] * W[a % len];
                x[n] += X->im[k] * W[b % len];
            } else {
                x[n] += X->re[k-len/2] * W[a % len];
                x[n] += X->im[k-len/2] * W[b % len];
            }
            a += n; b += n;
        }
    }

}

void idft2(fcomplex_t* Xl, fcomplex_t* Xr, float* xl, float* xr, size_t len) {
    // time and frequency domain data arrays
    int n, k;      // time and frequency domain indices

    // Calculate IDFT
    int to_sin = 3 * len / 4; // index offset for sin
    int a, b;
    for (n = 0; n < len; ++n) {
        xl[n] = 0; xr[n] = 0;
        a = 0; b = to_sin;
        for (k = 0; k < len; ++k) {
            if (k <= len/2) {
                xl[n] += Xl->re[k] * W[a % len];
                xl[n] += Xl->im[k] * W[b % len];
                xr[n] += Xr->re[k] * W[a % len];
                xr[n] += Xr->im[k] * W[b % len];
            } else {
                xl[n] += Xl->re[k-len/2] * W[a % len];
                xl[n] += Xl->im[k-len/2] * W[b % len];
                xr[n] += Xr->re[k-len/2] * W[a % len];
                xr[n] += Xr->im[k-len/2] * W[b % len];
            }
            a += n; b += n;
        }
    }
}

// int main()
// {
//     // time and frequency domain data arrays
//     int n, k;                     // time and frequency domain indices
//     float x[N];                   // discrete-time signal, x
//     float Xre[N/2+1], Xim[N/2+1]; // DFT of x (real and imaginary parts)
//     float P[N/2+1];               // power spectrum of x
//
//     // Generate random discrete-time signal x in range (-1,+1)
//     srand(time(0));
//     for (n=0 ; n<N ; ++n) x[n] = ((2.0 * rand()) / RAND_MAX) - 1.0 + sin(PI2 * n * 5.7 / N);
//
//     // Calculate DFT and power spectrum up to Nyquist frequency
//     int to_sin = 3*N/4; // index offset for sin
//     int a, b;
//     for (k=0 ; k<=N/2 ; ++k)
//     {
//         Xre[k] = 0; Xim[k] = 0;
//         a = 0; b = to_sin;
//         for (n=0 ; n<N ; ++n)
//         {
//             Xre[k] += x[n] * W[a%N];
//             Xim[k] -= x[n] * W[b%N];
//             a += k; b += k;
//         }
//         P[k] = Xre[k]*Xre[k] + Xim[k]*Xim[k];
//     }
//
//     // Output results to MATLAB / Octave M-file for plotting
//     FILE *f = fopen("dftplots.m", "w");
//     fprintf(f, "n = [0:%d];\n", N-1);
//     fprintf(f, "x = [ ");
//     for (n=0 ; n<N ; ++n) fprintf(f, "%f ", x[n]);
//     fprintf(f, "];\n");
//     fprintf(f, "Xre = [ ");
//     for (k=0 ; k<=N/2 ; ++k) fprintf(f, "%f ", Xre[k]);
//     fprintf(f, "];\n");
//     fprintf(f, "Xim = [ ");
//     for (k=0 ; k<=N/2 ; ++k) fprintf(f, "%f ", Xim[k]);
//     fprintf(f, "];\n");
//     fprintf(f, "P = [ ");
//     for (k=0 ; k<=N/2 ; ++k) fprintf(f, "%f ", P[k]);
//     fprintf(f, "];\n");
//     fprintf(f, "subplot(3,1,1)\nplot(n,x)\n");
//     fprintf(f, "xlim([0 %d])\n", N-1);
//     fprintf(f, "subplot(3,1,2)\nplot([0:%d],Xre,[0:%d],Xim)\n", N/2, N/2);
//     fprintf(f, "xlim([0 %d])\n", N/2);
//     fprintf(f, "subplot(3,1,3)\nstem([0:%d],P)\n", N/2);
//     fprintf(f, "xlim([0 %d])\n", N/2);
//     fclose(f);
//
//     // exit normally
//     return 0;
// }
